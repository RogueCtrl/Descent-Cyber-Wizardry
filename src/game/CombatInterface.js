/**\n * Combat Interface\n * Provides clean integration points between combat system and UI\n */\nclass CombatInterface {\n    constructor(eventSystem) {\n        this.eventSystem = eventSystem;\n        this.combat = new Combat();\n        this.formation = new Formation();\n        this.equipment = new Equipment();\n        this.encounterGenerator = new EncounterGenerator();\n        \n        this.setupEventListeners();\n    }\n    \n    /**\n     * Setup event listeners for combat events\n     */\n    setupEventListeners() {\n        this.eventSystem.on('combat-start-requested', this.handleCombatStart.bind(this));\n        this.eventSystem.on('combat-action-selected', this.handleActionSelected.bind(this));\n        this.eventSystem.on('combat-formation-change', this.handleFormationChange.bind(this));\n        this.eventSystem.on('combat-flee-attempt', this.handleFleeAttempt.bind(this));\n        this.eventSystem.on('combat-end-requested', this.handleCombatEnd.bind(this));\n    }\n    \n    /**\n     * Initialize combat encounter\n     */\n    initiateCombat(party, encounterType = 'random', dungeonLevel = 1) {\n        // Generate encounter\n        let encounter;\n        if (encounterType === 'boss') {\n            encounter = this.encounterGenerator.generateBossEncounter(dungeonLevel);\n        } else {\n            encounter = this.encounterGenerator.generateEncounter(party.level || 1, dungeonLevel);\n        }\n        \n        if (encounter.isEmpty) {\n            return {\n                success: false,\n                reason: 'no_encounter',\n                message: 'The area is quiet...'\n            };\n        }\n        \n        // Setup formation\n        const formationData = this.formation.setupFromParty(party);\n        \n        // Start combat\n        const combatStart = this.combat.startCombat(party, encounter.monsters);\n        \n        // Calculate difficulty\n        const difficulty = this.encounterGenerator.calculateDifficulty(\n            encounter, \n            party.averageLevel || 1, \n            party.size\n        );\n        \n        // Emit combat started event\n        this.eventSystem.emit('combat-started', {\n            encounter,\n            formation: formationData,\n            difficulty,\n            firstActor: combatStart,\n            surpriseRound: this.combat.surpriseRound\n        });\n        \n        return {\n            success: true,\n            encounter,\n            formation: formationData,\n            difficulty,\n            currentActor: combatStart\n        };\n    }\n    \n    /**\n     * Handle combat start event\n     */\n    handleCombatStart(data) {\n        const { party, encounterType, dungeonLevel } = data;\n        return this.initiateCombat(party, encounterType, dungeonLevel);\n    }\n    \n    /**\n     * Process combat action\n     */\n    processAction(action) {\n        // Validate action\n        const validation = this.validateAction(action);\n        if (!validation.valid) {\n            return {\n                success: false,\n                reason: validation.reason,\n                nextActor: this.combat.getCurrentActor()\n            };\n        }\n        \n        // Process the action through combat system\n        const result = this.combat.processAction(action);\n        \n        // Emit action processed event\n        this.eventSystem.emit('combat-action-processed', {\n            action,\n            result,\n            combatLog: this.combat.getCombatLog(),\n            nextActor: result.nextActor\n        });\n        \n        // Check for combat end\n        if (result.combatEnded) {\n            this.handleCombatEnd({\n                winner: result.winner,\n                experience: this.calculateExperienceGained(),\n                treasure: this.generateTreasure()\n            });\n        }\n        \n        return result;\n    }\n    \n    /**\n     * Handle action selection event\n     */\n    handleActionSelected(data) {\n        const { actionType, actor, target, options } = data;\n        \n        const action = {\n            type: actionType,\n            actor,\n            target,\n            ...options\n        };\n        \n        return this.processAction(action);\n    }\n    \n    /**\n     * Validate combat action\n     */\n    validateAction(action) {\n        if (!action.type) {\n            return { valid: false, reason: 'Action type is required' };\n        }\n        \n        if (!action.actor) {\n            return { valid: false, reason: 'Actor is required' };\n        }\n        \n        if (!action.actor.isAlive) {\n            return { valid: false, reason: 'Actor is not alive' };\n        }\n        \n        // Validate specific action types\n        switch (action.type) {\n            case 'attack':\n                if (!action.target) {\n                    return { valid: false, reason: 'Target is required for attack' };\n                }\n                if (!action.target.isAlive) {\n                    return { valid: false, reason: 'Target is not alive' };\n                }\n                // Check if attack is possible from current formation\n                const canAttack = this.formation.canAttackFromPosition(\n                    action.actor, \n                    action.target, \n                    action.attackType || 'melee'\n                );\n                if (!canAttack) {\n                    return { valid: false, reason: 'Cannot attack from current position' };\n                }\n                break;\n                \n            case 'spell':\n                if (!action.spell) {\n                    return { valid: false, reason: 'Spell is required' };\n                }\n                // Check if spell can be cast\n                const canCast = this.validateSpellCasting(action.actor, action.spell);\n                if (!canCast.valid) {\n                    return canCast;\n                }\n                break;\n                \n            case 'item':\n                if (!action.item) {\n                    return { valid: false, reason: 'Item is required' };\n                }\n                break;\n        }\n        \n        return { valid: true };\n    }\n    \n    /**\n     * Validate spell casting\n     */\n    validateSpellCasting(caster, spell) {\n        if (!caster.memorizedSpells) {\n            return { valid: false, reason: 'No spells memorized' };\n        }\n        \n        const schoolSpells = caster.memorizedSpells[spell.school] || [];\n        const hasSpell = schoolSpells.some(memorized => memorized.name === spell.name);\n        \n        if (!hasSpell) {\n            return { valid: false, reason: 'Spell not memorized' };\n        }\n        \n        return { valid: true };\n    }\n    \n    /**\n     * Handle formation change\n     */\n    handleFormationChange(data) {\n        const { character, targetRow } = data;\n        \n        const result = this.formation.moveCharacter(character, targetRow);\n        \n        if (result.success) {\n            this.eventSystem.emit('formation-changed', {\n                formation: this.formation.getFormationData(),\n                character,\n                newRow: targetRow\n            });\n        }\n        \n        return result;\n    }\n    \n    /**\n     * Handle flee attempt\n     */\n    handleFleeAttempt(data) {\n        const { character } = data;\n        \n        const fleeAction = {\n            type: 'flee',\n            fleer: character\n        };\n        \n        return this.processAction(fleeAction);\n    }\n    \n    /**\n     * Handle combat end\n     */\n    handleCombatEnd(data) {\n        this.combat.endCombat();\n        \n        this.eventSystem.emit('combat-ended', {\n            winner: data.winner,\n            experience: data.experience,\n            treasure: data.treasure,\n            combatLog: this.combat.getCombatLog()\n        });\n    }\n    \n    /**\n     * Calculate experience gained from combat\n     */\n    calculateExperienceGained() {\n        const totalXP = this.combat.combatants\n            .filter(combatant => !combatant.hasOwnProperty('class')) // Enemies only\n            .filter(enemy => !enemy.isAlive) // Defeated enemies\n            .reduce((sum, enemy) => sum + (enemy.experienceValue || 0), 0);\n            \n        return totalXP;\n    }\n    \n    /**\n     * Generate treasure from defeated enemies\n     */\n    generateTreasure() {\n        const defeatedEnemies = this.combat.combatants\n            .filter(combatant => !combatant.hasOwnProperty('class'))\n            .filter(enemy => !enemy.isAlive);\n        \n        const treasure = {\n            gold: 0,\n            items: []\n        };\n        \n        defeatedEnemies.forEach(enemy => {\n            // Generate gold based on enemy type\n            const goldValue = this.calculateGoldReward(enemy);\n            treasure.gold += goldValue;\n            \n            // Generate items based on treasure type\n            const items = this.generateItemRewards(enemy);\n            treasure.items.push(...items);\n        });\n        \n        return treasure;\n    }\n    \n    /**\n     * Calculate gold reward from enemy\n     */\n    calculateGoldReward(enemy) {\n        const baseGold = {\n            'poor': () => Random.dice(2, 6),\n            'standard': () => Random.dice(3, 6) * 10,\n            'rich': () => Random.dice(1, 6) * 100,\n            'hoard': () => Random.dice(2, 6) * 100,\n            'none': () => 0\n        };\n        \n        const treasureType = enemy.treasureType || 'none';\n        const goldFunction = baseGold[treasureType] || baseGold['none'];\n        \n        return goldFunction();\n    }\n    \n    /**\n     * Generate item rewards from enemy\n     */\n    generateItemRewards(enemy) {\n        const treasureType = enemy.treasureType || 'none';\n        \n        if (treasureType === 'none' || treasureType === 'poor') {\n            return [];\n        }\n        \n        const itemChances = {\n            'standard': 25,\n            'rich': 50,\n            'hoard': 75\n        };\n        \n        const chance = itemChances[treasureType] || 0;\n        \n        if (Random.percent(chance)) {\n            const itemLevel = enemy.level || 1;\n            return this.equipment.generateRandomLoot(itemLevel, 1);\n        }\n        \n        return [];\n    }\n    \n    /**\n     * Get current combat state for UI\n     */\n    getCombatState() {\n        if (!this.combat.isActive) {\n            return { active: false };\n        }\n        \n        return {\n            active: true,\n            currentTurn: this.combat.currentTurn,\n            currentActor: this.combat.getCurrentActor(),\n            combatants: this.combat.combatants.map(c => ({\n                name: c.name || 'Unknown',\n                currentHP: c.currentHP,\n                maxHP: c.maxHP,\n                isAlive: c.isAlive,\n                status: c.status,\n                isPlayer: c.hasOwnProperty('class')\n            })),\n            formation: this.formation.getFormationData(),\n            phase: this.combat.combatPhase,\n            log: this.combat.getCombatLog().slice(-10) // Last 10 entries\n        };\n    }\n    \n    /**\n     * Get available actions for current actor\n     */\n    getAvailableActions(actor) {\n        if (!actor || !actor.isAlive) {\n            return [];\n        }\n        \n        const actions = [];\n        \n        // Attack action\n        const enemies = this.combat.combatants.filter(c => \n            !c.hasOwnProperty('class') && c.isAlive\n        );\n        \n        if (enemies.length > 0) {\n            actions.push({\n                type: 'attack',\n                name: 'Attack',\n                description: 'Make a melee or ranged attack',\n                targets: enemies,\n                available: true\n            });\n        }\n        \n        // Spell actions\n        if (actor.memorizedSpells) {\n            const availableSpells = [];\n            \n            ['arcane', 'divine'].forEach(school => {\n                const schoolSpells = actor.memorizedSpells[school] || [];\n                availableSpells.push(...schoolSpells);\n            });\n            \n            if (availableSpells.length > 0) {\n                actions.push({\n                    type: 'spell',\n                    name: 'Cast Spell',\n                    description: 'Cast a memorized spell',\n                    spells: availableSpells,\n                    available: true\n                });\n            }\n        }\n        \n        // Defend action\n        actions.push({\n            type: 'defend',\n            name: 'Defend',\n            description: 'Take defensive stance (+2 AC until next turn)',\n            available: true\n        });\n        \n        // Item action (if implemented)\n        if (actor.inventory && actor.inventory.length > 0) {\n            actions.push({\n                type: 'item',\n                name: 'Use Item',\n                description: 'Use an item from inventory',\n                items: actor.inventory,\n                available: true\n            });\n        }\n        \n        // Flee action\n        actions.push({\n            type: 'flee',\n            name: 'Flee',\n            description: 'Attempt to escape from combat',\n            available: true\n        });\n        \n        return actions;\n    }\n    \n    /**\n     * Get formation management interface\n     */\n    getFormationInterface() {\n        return {\n            current: this.formation.getFormationData(),\n            stats: this.formation.getFormationStats(),\n            suggestions: this.formation.suggestFormationImprovements(),\n            canOptimize: true\n        };\n    }\n    \n    /**\n     * Auto-optimize formation\n     */\n    optimizeFormation() {\n        const result = this.formation.optimizeFormation();\n        \n        this.eventSystem.emit('formation-optimized', {\n            formation: result,\n            stats: this.formation.getFormationStats()\n        });\n        \n        return result;\n    }\n    \n    /**\n     * Process AI turn for monsters\n     */\n    processAITurn(monster) {\n        const playerTargets = this.combat.combatants.filter(c => \n            c.hasOwnProperty('class') && c.isAlive\n        );\n        \n        if (playerTargets.length === 0) {\n            return { action: 'wait', message: 'No valid targets' };\n        }\n        \n        const aiDecision = monster.chooseAction(playerTargets);\n        \n        if (aiDecision.action === 'attack') {\n            const attackResult = monster.performAttack(\n                aiDecision.attackIndex, \n                aiDecision.target\n            );\n            \n            // Emit AI action event\n            this.eventSystem.emit('ai-action-taken', {\n                monster,\n                action: aiDecision,\n                result: attackResult\n            });\n            \n            return attackResult;\n        }\n        \n        return aiDecision;\n    }\n    \n    /**\n     * Get combat statistics\n     */\n    getCombatStatistics() {\n        const players = this.combat.combatants.filter(c => c.hasOwnProperty('class'));\n        const enemies = this.combat.combatants.filter(c => !c.hasOwnProperty('class'));\n        \n        return {\n            turnNumber: this.combat.currentTurn,\n            totalCombatants: this.combat.combatants.length,\n            alivePlayers: players.filter(p => p.isAlive).length,\n            aliveEnemies: enemies.filter(e => e.isAlive).length,\n            totalDamageDealt: this.calculateTotalDamage('players'),\n            totalDamageTaken: this.calculateTotalDamage('enemies'),\n            actionsThisTurn: this.combat.combatLog.filter(entry => \n                entry.turn === this.combat.currentTurn\n            ).length\n        };\n    }\n    \n    /**\n     * Calculate total damage dealt by side\n     */\n    calculateTotalDamage(side) {\n        // This would need to be tracked throughout combat\n        // For now, return placeholder\n        return 0;\n    }\n    \n    /**\n     * Get combat help text\n     */\n    getCombatHelp() {\n        return {\n            overview: 'Combat is turn-based. Each character acts in initiative order.',\n            actions: {\n                attack: 'Roll to hit, then roll damage if successful. Some attacks may have special effects.',\n                spell: 'Cast a memorized spell. Success depends on caster level vs spell difficulty.',\n                defend: 'Gain +2 AC bonus until your next turn.',\n                item: 'Use a consumable item from your inventory.',\n                flee: 'Attempt to escape combat. Success depends on agility and class.'\n            },\n            formation: {\n                front: 'Front row characters take more damage but attack more effectively.',\n                back: 'Back row characters are protected but have limited melee options.'\n            },\n            tips: [\n                'Position spellcasters in the back row for protection',\n                'Use formation to your advantage - fighters in front, casters in back',\n                'Some weapons have reach and can attack from the back row',\n                'Ranged attacks can target any enemy regardless of formation'\n            ]\n        };\n    }\n}"