/**
 * Monster System
 * Handles enemy creatures and encounter generation
 */
class Monster {
    constructor(monsterType = 'Kobold') {
        const data = Monster.getMonsterData(monsterType);
        
        this.name = data.name;
        this.type = data.type;
        this.level = data.level;
        this.hitDie = data.hitDie;
        this.maxHP = this.rollHP(data.hitDie, data.level);
        this.currentHP = this.maxHP;
        this.isAlive = true;
        this.status = 'OK';
        
        // Attributes (simplified for monsters)
        this.attributes = {
            strength: data.strength || 10,
            intelligence: data.intelligence || 10,
            agility: data.agility || 10,
            vitality: data.vitality || 10
        };
        
        // Combat stats
        this.armorClass = data.armorClass || 10;
        this.attackBonus = data.attackBonus || 0;
        this.damageBonus = data.damageBonus || 0;
        this.attacks = data.attacks || [{ name: 'Basic Attack', damage: { dice: 1, sides: 6 } }];
        
        // Special abilities
        this.abilities = data.abilities || [];
        this.resistances = data.resistances || [];
        this.immunities = data.immunities || [];
        
        // AI behavior
        this.aiType = data.aiType || 'aggressive';
        this.preferredTargets = data.preferredTargets || ['front'];
        
        // Experience and treasure
        this.experienceValue = data.experienceValue || 10;
        this.treasureType = data.treasureType || 'none';
        
        // Generate unique ID
        this.id = Helpers.generateId('monster');
    }
    
    /**
     * Monster database
     */
    static getMonsterData(monsterType) {\n        const monsters = {\n            // Level 1 Monsters\n            'Kobold': {\n                name: 'Kobold',\n                type: 'humanoid',\n                level: 1,\n                hitDie: 4,\n                strength: 8,\n                intelligence: 10,\n                agility: 15,\n                vitality: 9,\n                armorClass: 7,\n                attackBonus: 0,\n                damageBonus: -1,\n                attacks: [\n                    { name: 'Short Sword', damage: { dice: 1, sides: 6, bonus: -1 } },\n                    { name: 'Sling', damage: { dice: 1, sides: 4 }, range: 'ranged' }\n                ],\n                abilities: ['pack_tactics'],\n                aiType: 'cowardly',\n                preferredTargets: ['weakest'],\n                experienceValue: 25,\n                treasureType: 'poor'\n            },\n            'Giant Rat': {\n                name: 'Giant Rat',\n                type: 'beast',\n                level: 1,\n                hitDie: 4,\n                strength: 7,\n                intelligence: 2,\n                agility: 15,\n                vitality: 12,\n                armorClass: 7,\n                attackBonus: 1,\n                damageBonus: -2,\n                attacks: [\n                    { name: 'Bite', damage: { dice: 1, sides: 3 }, special: ['disease'] }\n                ],\n                abilities: ['disease_bite'],\n                resistances: ['disease'],\n                aiType: 'aggressive',\n                preferredTargets: ['random'],\n                experienceValue: 10,\n                treasureType: 'none'\n            },\n            'Skeleton': {\n                name: 'Skeleton',\n                type: 'undead',\n                level: 1,\n                hitDie: 6,\n                strength: 10,\n                intelligence: 10,\n                agility: 14,\n                vitality: 15,\n                armorClass: 7,\n                attackBonus: 0,\n                damageBonus: 0,\n                attacks: [\n                    { name: 'Claw', damage: { dice: 1, sides: 6 } }\n                ],\n                resistances: ['cold', 'necrotic'],\n                immunities: ['poison', 'disease'],\n                aiType: 'aggressive',\n                preferredTargets: ['front'],\n                experienceValue: 50,\n                treasureType: 'poor'\n            },\n            \n            // Level 2-3 Monsters\n            'Orc': {\n                name: 'Orc',\n                type: 'humanoid',\n                level: 2,\n                hitDie: 6,\n                strength: 16,\n                intelligence: 7,\n                agility: 12,\n                vitality: 16,\n                armorClass: 6,\n                attackBonus: 1,\n                damageBonus: 3,\n                attacks: [\n                    { name: 'Battleaxe', damage: { dice: 1, sides: 8, bonus: 3 } },\n                    { name: 'Javelin', damage: { dice: 1, sides: 6, bonus: 3 }, range: 'thrown' }\n                ],\n                abilities: ['aggressive'],\n                aiType: 'aggressive',\n                preferredTargets: ['strongest'],\n                experienceValue: 100,\n                treasureType: 'standard'\n            },\n            'Wolf': {\n                name: 'Wolf',\n                type: 'beast',\n                level: 2,\n                hitDie: 6,\n                strength: 12,\n                intelligence: 3,\n                agility: 15,\n                vitality: 12,\n                armorClass: 7,\n                attackBonus: 2,\n                damageBonus: 1,\n                attacks: [\n                    { name: 'Bite', damage: { dice: 2, sides: 4, bonus: 2 }, special: ['knockdown'] }\n                ],\n                abilities: ['pack_tactics', 'keen_hearing'],\n                aiType: 'pack',\n                preferredTargets: ['isolated'],\n                experienceValue: 50,\n                treasureType: 'none'\n            },\n            'Hobgoblin': {\n                name: 'Hobgoblin',\n                type: 'humanoid',\n                level: 3,\n                hitDie: 8,\n                strength: 13,\n                intelligence: 12,\n                agility: 12,\n                vitality: 12,\n                armorClass: 5,\n                attackBonus: 2,\n                damageBonus: 1,\n                attacks: [\n                    { name: 'Longsword', damage: { dice: 1, sides: 8, bonus: 1 } },\n                    { name: 'Longbow', damage: { dice: 1, sides: 8, bonus: 1 }, range: 'ranged' }\n                ],\n                abilities: ['martial_advantage'],\n                aiType: 'tactical',\n                preferredTargets: ['spellcasters'],\n                experienceValue: 200,\n                treasureType: 'standard'\n            },\n            \n            // Level 4-5 Monsters\n            'Ogre': {\n                name: 'Ogre',\n                type: 'giant',\n                level: 4,\n                hitDie: 10,\n                strength: 19,\n                intelligence: 5,\n                agility: 8,\n                vitality: 16,\n                armorClass: 5,\n                attackBonus: 3,\n                damageBonus: 4,\n                attacks: [\n                    { name: 'Greatclub', damage: { dice: 2, sides: 8, bonus: 4 } },\n                    { name: 'Javelin', damage: { dice: 2, sides: 6, bonus: 4 }, range: 'thrown' }\n                ],\n                abilities: ['powerful_build'],\n                aiType: 'aggressive',\n                preferredTargets: ['front'],\n                experienceValue: 450,\n                treasureType: 'standard'\n            },\n            'Owlbear': {\n                name: 'Owlbear',\n                type: 'monstrosity',\n                level: 5,\n                hitDie: 10,\n                strength: 20,\n                intelligence: 3,\n                agility: 12,\n                vitality: 17,\n                armorClass: 6,\n                attackBonus: 4,\n                damageBonus: 5,\n                attacks: [\n                    { name: 'Claw', damage: { dice: 2, sides: 8, bonus: 5 } },\n                    { name: 'Bite', damage: { dice: 1, sides: 10, bonus: 5 } }\n                ],\n                abilities: ['multiattack', 'keen_sight'],\n                aiType: 'aggressive',\n                preferredTargets: ['random'],\n                experienceValue: 700,\n                treasureType: 'rich'\n            },\n            \n            // Boss Monsters\n            'Orc Chief': {\n                name: 'Orc Chief',\n                type: 'humanoid',\n                level: 6,\n                hitDie: 8,\n                strength: 18,\n                intelligence: 12,\n                agility: 12,\n                vitality: 18,\n                armorClass: 4,\n                attackBonus: 5,\n                damageBonus: 4,\n                attacks: [\n                    { name: 'Magic Axe +1', damage: { dice: 1, sides: 8, bonus: 5 }, magical: true },\n                    { name: 'Spear', damage: { dice: 1, sides: 6, bonus: 4 }, range: 'thrown' }\n                ],\n                abilities: ['leadership', 'aggressive', 'multiattack'],\n                aiType: 'tactical',\n                preferredTargets: ['strongest'],\n                experienceValue: 1100,\n                treasureType: 'rich'\n            },\n            'Young Dragon': {\n                name: 'Young Dragon',\n                type: 'dragon',\n                level: 8,\n                hitDie: 12,\n                strength: 23,\n                intelligence: 14,\n                agility: 10,\n                vitality: 21,\n                armorClass: 2,\n                attackBonus: 7,\n                damageBonus: 6,\n                attacks: [\n                    { name: 'Bite', damage: { dice: 2, sides: 10, bonus: 6 } },\n                    { name: 'Claw', damage: { dice: 2, sides: 6, bonus: 6 } },\n                    { name: 'Fire Breath', damage: { dice: 8, sides: 6 }, range: 'area', special: ['fire'] }\n                ],\n                abilities: ['multiattack', 'breath_weapon', 'frightful_presence', 'magic_resistance'],\n                resistances: ['fire', 'physical'],\n                immunities: ['fire', 'sleep', 'paralysis'],\n                aiType: 'intelligent',\n                preferredTargets: ['spellcasters'],\n                experienceValue: 2300,\n                treasureType: 'hoard'\n            }\n        };\n        \n        return monsters[monsterType] || monsters['Kobold'];\n    }\n    \n    /**\n     * Roll hit points for monster\n     */\n    rollHP(hitDie, level) {\n        let hp = 0;\n        for (let i = 0; i < level; i++) {\n            hp += Random.die(hitDie);\n        }\n        \n        // Add constitution bonus\n        const conBonus = Math.floor((this.attributes?.vitality - 10) / 2) || 0;\n        hp += conBonus * level;\n        \n        return Math.max(1, hp);\n    }\n    \n    /**\n     * Get monster's attack options\n     */\n    getAttackOptions() {\n        return this.attacks.map((attack, index) => ({\n            id: index,\n            name: attack.name,\n            damage: attack.damage,\n            range: attack.range || 'melee',\n            special: attack.special || [],\n            magical: attack.magical || false\n        }));\n    }\n    \n    /**\n     * Perform monster attack\n     */\n    performAttack(attackIndex, target) {\n        if (attackIndex >= this.attacks.length) {\n            return { success: false, message: 'Invalid attack' };\n        }\n        \n        const attack = this.attacks[attackIndex];\n        \n        // Calculate attack roll\n        const attackRoll = Random.die(20) + this.attackBonus;\n        const targetAC = this.calculateTargetAC(target);\n        \n        if (attackRoll >= targetAC) {\n            // Hit! Calculate damage\n            let damage = Random.dice(attack.damage.dice, attack.damage.sides);\n            damage += attack.damage.bonus || 0;\n            damage += this.damageBonus;\n            damage = Math.max(1, damage);\n            \n            // Apply damage\n            target.currentHP = Math.max(0, target.currentHP - damage);\n            \n            if (target.currentHP <= 0) {\n                target.isAlive = false;\n                target.status = target.currentHP <= -10 ? 'dead' : 'unconscious';\n            }\n            \n            // Apply special effects\n            const specialEffects = this.applySpecialEffects(attack, target);\n            \n            return {\n                success: true,\n                hit: true,\n                damage: damage,\n                attack: attack.name,\n                specialEffects: specialEffects,\n                message: `${this.name} hits ${target.name || 'target'} with ${attack.name} for ${damage} damage!`\n            };\n        } else {\n            return {\n                success: true,\n                hit: false,\n                attack: attack.name,\n                message: `${this.name} misses ${target.name || 'target'} with ${attack.name}`\n            };\n        }\n    }\n    \n    /**\n     * Calculate target AC (simplified)\n     */\n    calculateTargetAC(target) {\n        let ac = 10; // Base AC\n        \n        if (target.attributes) {\n            ac -= Math.floor((target.attributes.agility - 10) / 2);\n        }\n        \n        // Equipment bonuses (if available)\n        if (target.equipment) {\n            const equipment = new Equipment();\n            ac -= equipment.calculateACBonus(target);\n        }\n        \n        return ac;\n    }\n    \n    /**\n     * Apply special attack effects\n     */\n    applySpecialEffects(attack, target) {\n        const effects = [];\n        \n        if (attack.special) {\n            attack.special.forEach(effect => {\n                switch (effect) {\n                    case 'disease':\n                        if (Random.percent(25)) {\n                            target.addTemporaryEffect?.({\n                                type: 'disease',\n                                duration: 'long',\n                                effect: 'stat_drain',\n                                stat: 'vitality',\n                                amount: 1\n                            });\n                            effects.push('diseased');\n                        }\n                        break;\n                    \n                    case 'knockdown':\n                        if (Random.percent(50)) {\n                            target.addTemporaryEffect?.({\n                                type: 'knockdown',\n                                duration: 1,\n                                effect: 'prone'\n                            });\n                            effects.push('knocked down');\n                        }\n                        break;\n                    \n                    case 'fire':\n                        // Fire damage (already included in damage calculation)\n                        effects.push('burning');\n                        break;\n                }\n            });\n        }\n        \n        return effects;\n    }\n    \n    /**\n     * Monster AI decision making\n     */\n    chooseAction(targets, allies = []) {\n        const availableTargets = targets.filter(target => target.isAlive);\n        if (availableTargets.length === 0) {\n            return { action: 'wait' };\n        }\n        \n        // Choose target based on AI type\n        const target = this.chooseTarget(availableTargets, allies);\n        \n        // Choose attack based on situation\n        const attackIndex = this.chooseAttack(target, availableTargets);\n        \n        return {\n            action: 'attack',\n            target: target,\n            attackIndex: attackIndex\n        };\n    }\n    \n    /**\n     * Choose target based on AI behavior\n     */\n    chooseTarget(targets, allies) {\n        switch (this.aiType) {\n            case 'cowardly':\n                // Target weakest enemy\n                return targets.reduce((weakest, current) => \n                    current.currentHP < weakest.currentHP ? current : weakest\n                );\n                \n            case 'aggressive':\n                // Target closest enemy (simplified to random front row)\n                const frontTargets = targets.filter(target => \n                    this.preferredTargets.includes('front') || this.preferredTargets.includes('random')\n                );\n                return frontTargets.length > 0 ? Random.choice(frontTargets) : Random.choice(targets);\n                \n            case 'tactical':\n                // Target spellcasters first\n                const spellcasters = targets.filter(target => \n                    ['Mage', 'Priest', 'Bishop'].includes(target.class)\n                );\n                return spellcasters.length > 0 ? Random.choice(spellcasters) : Random.choice(targets);\n                \n            case 'pack':\n                // Target isolated enemies\n                // For now, just target random\n                return Random.choice(targets);\n                \n            case 'intelligent':\n                // Complex targeting logic\n                return this.intelligentTargeting(targets, allies);\n                \n            default:\n                return Random.choice(targets);\n        }\n    }\n    \n    /**\n     * Intelligent targeting for smart monsters\n     */\n    intelligentTargeting(targets, allies) {\n        // Score each target\n        const scoredTargets = targets.map(target => {\n            let score = 0;\n            \n            // Prefer injured targets\n            const hpRatio = target.currentHP / target.maxHP;\n            score += (1 - hpRatio) * 30;\n            \n            // Prefer spellcasters\n            if (['Mage', 'Priest', 'Bishop'].includes(target.class)) {\n                score += 20;\n            }\n            \n            // Prefer low AC targets\n            const ac = this.calculateTargetAC(target);\n            score += Math.max(0, 15 - ac) * 2;\n            \n            // Prefer targets that can be easily hit\n            const hitChance = (21 - ac + this.attackBonus) * 5;\n            score += hitChance;\n            \n            return { target, score };\n        });\n        \n        // Sort by score and return best target\n        scoredTargets.sort((a, b) => b.score - a.score);\n        return scoredTargets[0].target;\n    }\n    \n    /**\n     * Choose best attack for situation\n     */\n    chooseAttack(target, allTargets) {\n        // For now, simple logic\n        if (this.attacks.length === 1) return 0;\n        \n        // Prefer area attacks if multiple targets\n        const areaAttacks = this.attacks.filter((attack, index) => \n            attack.range === 'area' && allTargets.length >= 3\n        );\n        \n        if (areaAttacks.length > 0) {\n            return this.attacks.indexOf(areaAttacks[0]);\n        }\n        \n        // Prefer ranged attacks if target is far (simplified)\n        const rangedAttacks = this.attacks.filter(attack => \n            attack.range === 'ranged' || attack.range === 'thrown'\n        );\n        \n        if (rangedAttacks.length > 0 && Random.percent(30)) {\n            return this.attacks.indexOf(Random.choice(rangedAttacks));\n        }\n        \n        // Default to first attack\n        return 0;\n    }\n    \n    /**\n     * Check if monster has specific ability\n     */\n    hasAbility(abilityName) {\n        return this.abilities.includes(abilityName);\n    }\n    \n    /**\n     * Use special ability\n     */\n    useAbility(abilityName, targets) {\n        switch (abilityName) {\n            case 'breath_weapon':\n                return this.useBreathWeapon(targets);\n            case 'frightful_presence':\n                return this.useFrightfulPresence(targets);\n            case 'multiattack':\n                return this.useMultiattack(targets);\n            default:\n                return { success: false, message: 'Unknown ability' };\n        }\n    }\n    \n    /**\n     * Use breath weapon (dragons)\n     */\n    useBreathWeapon(targets) {\n        const breathAttack = this.attacks.find(attack => attack.special?.includes('fire'));\n        if (!breathAttack) return { success: false };\n        \n        const results = [];\n        targets.forEach(target => {\n            if (target.isAlive) {\n                const damage = Random.dice(breathAttack.damage.dice, breathAttack.damage.sides);\n                target.currentHP = Math.max(0, target.currentHP - damage);\n                if (target.currentHP <= 0) {\n                    target.isAlive = false;\n                    target.status = 'dead';\n                }\n                results.push({ target, damage });\n            }\n        });\n        \n        return {\n            success: true,\n            message: `${this.name} breathes fire!`,\n            results: results\n        };\n    }\n    \n    /**\n     * Use frightful presence\n     */\n    useFrightfulPresence(targets) {\n        const affected = [];\n        targets.forEach(target => {\n            if (target.level < this.level && Random.percent(50)) {\n                target.addTemporaryEffect?.({\n                    type: 'fear',\n                    duration: 3,\n                    effect: 'disadvantage'\n                });\n                affected.push(target);\n            }\n        });\n        \n        return {\n            success: true,\n            message: `${this.name} roars terrifyingly!`,\n            affected: affected\n        };\n    }\n    \n    /**\n     * Use multiattack\n     */\n    useMultiattack(targets) {\n        const results = [];\n        const attackCount = this.level >= 5 ? 2 : 1;\n        \n        for (let i = 0; i < attackCount; i++) {\n            const target = Random.choice(targets.filter(t => t.isAlive));\n            if (target) {\n                const result = this.performAttack(0, target);\n                results.push(result);\n            }\n        }\n        \n        return {\n            success: true,\n            message: `${this.name} attacks multiple times!`,\n            attacks: results\n        };\n    }\n    \n    /**\n     * Get save data\n     */\n    getSaveData() {\n        return {\n            name: this.name,\n            type: this.type,\n            level: this.level,\n            maxHP: this.maxHP,\n            currentHP: this.currentHP,\n            isAlive: this.isAlive,\n            status: this.status,\n            attributes: { ...this.attributes },\n            armorClass: this.armorClass,\n            attackBonus: this.attackBonus,\n            damageBonus: this.damageBonus,\n            id: this.id\n        };\n    }\n    \n    /**\n     * Load from save data\n     */\n    loadFromSave(saveData) {\n        if (!saveData) return;\n        \n        Object.keys(saveData).forEach(key => {\n            if (this.hasOwnProperty(key)) {\n                this[key] = saveData[key];\n            }\n        });\n    }\n}\n\n/**\n * Encounter Generator\n * Creates monster encounters for dungeons\n */\nclass EncounterGenerator {\n    constructor() {\n        this.encounterTables = this.initializeEncounterTables();\n    }\n    \n    /**\n     * Initialize encounter tables by level\n     */\n    initializeEncounterTables() {\n        return {\n            1: [\n                { monsters: ['Kobold'], count: [2, 4], weight: 30 },\n                { monsters: ['Giant Rat'], count: [3, 6], weight: 25 },\n                { monsters: ['Skeleton'], count: [1, 2], weight: 20 },\n                { monsters: ['Kobold', 'Giant Rat'], count: [1, 2], weight: 15 },\n                { monsters: [], count: [0], weight: 10 } // Empty encounter\n            ],\n            2: [\n                { monsters: ['Orc'], count: [1, 3], weight: 25 },\n                { monsters: ['Wolf'], count: [2, 4], weight: 20 },\n                { monsters: ['Kobold'], count: [4, 8], weight: 20 },\n                { monsters: ['Skeleton'], count: [2, 4], weight: 15 },\n                { monsters: ['Orc', 'Kobold'], count: [1, 3], weight: 15 },\n                { monsters: [], count: [0], weight: 5 }\n            ],\n            3: [\n                { monsters: ['Hobgoblin'], count: [1, 2], weight: 25 },\n                { monsters: ['Orc'], count: [2, 4], weight: 20 },\n                { monsters: ['Wolf'], count: [3, 6], weight: 15 },\n                { monsters: ['Hobgoblin', 'Orc'], count: [1, 2], weight: 20 },\n                { monsters: ['Skeleton'], count: [3, 6], weight: 15 },\n                { monsters: [], count: [0], weight: 5 }\n            ],\n            4: [\n                { monsters: ['Ogre'], count: [1], weight: 20 },\n                { monsters: ['Hobgoblin'], count: [2, 4], weight: 25 },\n                { monsters: ['Orc'], count: [3, 6], weight: 20 },\n                { monsters: ['Ogre', 'Orc'], count: [1, 2], weight: 15 },\n                { monsters: ['Hobgoblin', 'Wolf'], count: [1, 3], weight: 15 },\n                { monsters: [], count: [0], weight: 5 }\n            ],\n            5: [\n                { monsters: ['Owlbear'], count: [1], weight: 15 },\n                { monsters: ['Ogre'], count: [1, 2], weight: 20 },\n                { monsters: ['Orc Chief'], count: [1], weight: 10 },\n                { monsters: ['Hobgoblin'], count: [3, 6], weight: 25 },\n                { monsters: ['Ogre', 'Hobgoblin'], count: [1, 2], weight: 20 },\n                { monsters: ['Owlbear', 'Wolf'], count: [1, 2], weight: 5 },\n                { monsters: [], count: [0], weight: 5 }\n            ]\n        };\n    }\n    \n    /**\n     * Generate random encounter\n     */\n    generateEncounter(partyLevel, dungeonLevel = 1) {\n        const effectiveLevel = Math.min(5, Math.max(1, dungeonLevel));\n        const table = this.encounterTables[effectiveLevel];\n        \n        // Choose encounter type based on weights\n        const totalWeight = table.reduce((sum, entry) => sum + entry.weight, 0);\n        const roll = Random.integer(1, totalWeight);\n        \n        let currentWeight = 0;\n        let chosenEncounter = null;\n        \n        for (const entry of table) {\n            currentWeight += entry.weight;\n            if (roll <= currentWeight) {\n                chosenEncounter = entry;\n                break;\n            }\n        }\n        \n        if (!chosenEncounter || chosenEncounter.monsters.length === 0) {\n            return { monsters: [], isEmpty: true };\n        }\n        \n        // Generate monsters\n        const encounter = { monsters: [], isEmpty: false };\n        \n        chosenEncounter.monsters.forEach(monsterType => {\n            const count = Array.isArray(chosenEncounter.count) ? \n                Random.integer(chosenEncounter.count[0], chosenEncounter.count[1]) :\n                chosenEncounter.count;\n                \n            for (let i = 0; i < count; i++) {\n                encounter.monsters.push(new Monster(monsterType));\n            }\n        });\n        \n        return encounter;\n    }\n    \n    /**\n     * Generate boss encounter\n     */\n    generateBossEncounter(dungeonLevel) {\n        const bossTypes = {\n            1: ['Orc Chief'],\n            2: ['Orc Chief'],\n            3: ['Young Dragon'],\n            4: ['Young Dragon'],\n            5: ['Young Dragon']\n        };\n        \n        const level = Math.min(5, Math.max(1, dungeonLevel));\n        const possibleBosses = bossTypes[level];\n        const bossType = Random.choice(possibleBosses);\n        \n        const encounter = {\n            monsters: [new Monster(bossType)],\n            isBoss: true,\n            isEmpty: false\n        };\n        \n        // Add some minions\n        const minionCount = Random.integer(1, 3);\n        const minionTypes = level <= 2 ? ['Orc', 'Kobold'] : ['Hobgoblin', 'Orc'];\n        \n        for (let i = 0; i < minionCount; i++) {\n            const minionType = Random.choice(minionTypes);\n            encounter.monsters.push(new Monster(minionType));\n        }\n        \n        return encounter;\n    }\n    \n    /**\n     * Calculate encounter difficulty\n     */\n    calculateDifficulty(encounter, partyLevel, partySize) {\n        const totalXP = encounter.monsters.reduce((sum, monster) => \n            sum + monster.experienceValue, 0\n        );\n        \n        const expectedXPPerCharacter = partyLevel * 100;\n        const partyXPBudget = expectedXPPerCharacter * partySize;\n        \n        const difficultyRatio = totalXP / partyXPBudget;\n        \n        if (difficultyRatio < 0.3) return 'trivial';\n        if (difficultyRatio < 0.5) return 'easy';\n        if (difficultyRatio < 0.8) return 'medium';\n        if (difficultyRatio < 1.2) return 'hard';\n        return 'deadly';\n    }\n}